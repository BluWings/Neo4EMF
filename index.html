<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>NEO4EMF by amine-ben</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>NEO4EMF</h1>
        <p>EMF, NEO4J, Model repository</p>

        <p class="view"><a href="https://github.com/amine-ben/Neo4EMF">View the Project on GitHub <small>amine-ben/Neo4EMF</small></a></p>


        <ul>
          <li><a href="https://github.com/amine-ben/Neo4EMF/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/amine-ben/Neo4EMF/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/amine-ben/Neo4EMF">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h2>
<a name="presentation" class="anchor" href="#presentation"><span class="octicon octicon-link"></span></a>Presentation</h2>

<p>One of the main limitations hampering the adoption of modeling technologies for large-scale systems is the lack of solutions to efficiently handle big, complex and highly interconnected data models. This project introduces NEO4EMF, a Neo4j-based model repository and persistence framework allowing on-demand loading, storage, and unloading of large-scale EMF models. Neo4EMF uses a sophisticated unloading approach apart from simple Soft/Weak references. Moreover, Neo4EMF provides a No-SQL database persistence framework based on Neo4j, which is a transactional property-graph database that proved a remarkable running speed for connected data operations compared to relational databases.</p>

<p>In terms of performance, Neo4EMF eases data access and storage not only in a manner to reduce time and memory usage but also to allow big models to fit into small memory. This is established through an on-demand loading mechanism that is analogous to CDO but with a few differences:</p>

<ol>
<li>Lightweight first time loading of model elements: we separated EMF objects and their data fields, thus, data objects are only instantiated if an access request to one of their fields is established</li>
<li>Static and dynamic partitioning of model elements: a partition represents a group of model elements to be unloaded all together. Hence, after each EMF operation call, first time loading objects are organized in their suitable partition according to the partitioning strategy.</li>
<li>Unloading of partitions: when memory reaches a given threshold, we use a selection strategy to choose one or more partitions to be removed from the memory.</li>
</ol><p>We adapted the EMF java code generation templates for a refined on-demand loading mechanism, we separated data (attributes and references : see figure below ) of their objects for a lighter first time loading. They are implemented as inner classes within their containers. Data objects  And data fields are filled in when due.</p>

<p></p>
<img src="http://i40.tinypic.com/99oswy.jpg" alt="Respresentation of objects and their models" align="middle">

<h2>
<a name="wiki" class="anchor" href="#wiki"><span class="octicon octicon-link"></span></a>Wiki</h2>

<h3>
<a name="generating-java-code" class="anchor" href="#generating-java-code"><span class="octicon octicon-link"></span></a>Generating java code</h3>

<p>Having an ecore model and its genmodel, first you edit the genmodel properties as illustrated by the figure : </p>

<p></p>
<img src="http://i41.tinypic.com/fdu99z.png" alt="Genmodel properties" align="middle">

<p>Therewith double-click the genModel and the right-click its windows and generate model code as depicted by the later figure :</p>

<p></p>
<img src="http://i40.tinypic.com/k9ewt5.png" alt="Genmodel properties" align="middle">

<h3>
<a name="neo4emf-resource-creation-" class="anchor" href="#neo4emf-resource-creation-"><span class="octicon octicon-link"></span></a>Neo4EMF Resource creation :</h3>

<p><code>// Create the resourceSet
        ResourceSet resourceSet = new ResourceSetImpl();
        // Create an URI with neo4emf as protocol 
        URI uri = URI.createURI("neo4emf:/./MyFirstNeo4emfResource");
        // attach this protocol to INeo4emfResourceFactory 
        resourceSet.getResourceFactoryRegistry().getProtocolToFactoryMap().put("neo4emf", 
                INeo4emfResourceFactory.eINSTANCE.setRelationshipsMap(reltypes
                        .ReltypesMappings.getInstance().getMap()));
        // Create the resource
        INeo4emfResource resource = (INeo4emfResource) resourceSet.createResource(uri);
        // Register the package
        EPackage.Registry.INSTANCE.put(MgraphPackage.eINSTANCE.getNsURI(), MgraphPackage.eINSTANCE);</code> </p>

<h3>
<a name="neo4emf-common-option-" class="anchor" href="#neo4emf-common-option-"><span class="octicon octicon-link"></span></a>Neo4emf common option :</h3>

<p>// TO COME</p>

<h3>
<a name="load-a-resource-" class="anchor" href="#load-a-resource-"><span class="octicon octicon-link"></span></a>Load a resource :</h3>

<h4>
<a name="load-root-objects" class="anchor" href="#load-root-objects"><span class="octicon octicon-link"></span></a>Load root objects</h4>

<p>to load the root elements of a resource you simply use the load method
<code>resource.load(null);</code></p>

<h4>
<a name="load-all-instances-of-some-type" class="anchor" href="#load-all-instances-of-some-type"><span class="octicon octicon-link"></span></a>Load all Instances of some type</h4>

<p><code>((INeo4emfResource)resource).getAllInstances($Package_class_name$.Literals.$Eclass_name$);</code></p>

<h3>
<a name="save-a-resource-" class="anchor" href="#save-a-resource-"><span class="octicon octicon-link"></span></a>Save a resource :</h3>

<p>Neo4emf come with a light-weight changelog recorder, so there is no need to add the newly created elements to the resource contents. To save the elements you simply use the save method 
<code>resource.save(null);</code></p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/amine-ben">amine-ben</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>